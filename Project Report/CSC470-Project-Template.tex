\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{todonotes}
\usepackage{array}
\usepackage{subcaption}
\usepackage{graphicx}

\title{CSC470: Software Engineering Final Report\\ TESS: The Extraordinary Sudoku Solver}
\author{Team: \#1 \\David Koval and Joseph Mammo\\Instructor: Dr. Ahyoung Lee}
\date{ 4/24/17 \\ v1.1 }

 
\renewcommand*\contentsname{Table of Contents}

 
\begin{document}
 
\maketitle

\clearpage

\tableofcontents

\clearpage

\section{Executive Summary} 
\todo{Copied from previous paper} Have you ever played a Sudoku game that you weren’t able to solve? Have you spent hours trying to solve a specific puzzle, but something never quite added up? This is where we come in. with The Extraordinary Sudoku Solver, or as everyone in the lab calls it, TESS. TESS isn’t a normal sudoku game, it allows normal game play much like any sudoku game will; however, it has an added feature that makes it stand out from the rest of the apps currently on the market. TESS allows a user to input the given values from a sudoku puzzle and work its magic to find a solution for you. David and Joseph are currently working on TESS to get her up and running. 
	The goal of TESS is to allow a user to play different sudoku games, much like most of the apps currently out there, but also allow a user to input a sudoku puzzle they have been working on elsewhere and get an instant solution. There are a few major problems that the developers are facing. One of the biggest problems in the time efficiency. TESS needs to be able to solve the entire game in under 5 seconds and even though that may seem like a long time, going through all the possible solutions won’t be fast enough. The developers are currently working on an algorithm that will work in O(N\^5) which is roughly 3 billion computations; however, with pruning and better algorithms, they will be able to get the algorithm to solve it much faster. Another major problem the young developers face is the allotted time to finish the project, they only have about a month to finish this massive project. They might be able to finish the project on time, if they dedicate enough time towards this project and focus on it more than the previous projects they worked on. 
	The design will be rather simple much like any sudoku game out there; however, the color scheme will be different with a nice black and neon green coloring pattern. There will be a few buttons such as choosing to play a game as well as the ability to access the solver to solve a sudoku puzzle the user might have.
	The goals of this project is to allow the user to play a sudoku game. The user should be able to pick a game from the our database and be able to play it. It will require the developers to manage different difficulty levels as well as storing games in the database. Another goal for this project is to allow the user to check how they are doing so far. This will require the developers to write testers that will test if the current numbers are valid or invalid. The major goal of this project is to completely solve the sudoku puzzle that the user inputs. Some problems that will arise are due to the time constraint. Brute force will take too long; however, if depth first search is used along with pruning, there is a good chance it will finish in time.
	The system design is like how most games would be structured. The user can select play or solve at the very beginning. If the user decides to play a game, then they will be able to choose a difficulty they would like to play. There will be options for a hint; however, the hint function might not be released with the first version, since that isn’t the main priority with the project. There will be a check option to check if there are any errors in the current state of the puzzle as well as a solve option to solve the rest of the puzzle.  The following description is outlined in figure 2. The sequence diagram (Figure 3) illustrates the flow of logic when a user decides to play the game. Finally, the activity diagram (Figure 4) greatly outlines the dynamic aspects of the proposed sudoku game.
The test plan for this project is based on the bottom-up approach. We, the developers, will be focusing on utility, reliability, robustness, and performance to ensure this project is functional and well as enjoyable to the user.



 
\section{Introduction}
 This section will provide the introduction to the final report document as well as roughly highlight the project on hand.
\subsection{Purpose}
The purpose of this document is to give a detailed and overall description of The Extraordinary Sudoku Solver (TESS) app. The overall purpose of this project is to help the avid Sudoku players to have a platform to enjoy the game on as well as get help when they are unable to solve a puzzle. This app is intended to be used by both amateurs and professionals, as well as anyone in-between. This will be a free platform for anyone to have access to it as well as modify it in any way the like. Sudoku is an amazing game and the hopes of this project is to expand the entertainment and excitement of Sudoku to anyone willing to try this app.

\subsection{Definitions, acronyms, and abbreviations}

\begin{tabular}{ | m{8em} | m{24em}|  } 
\hline
\textbf{Term}& \textbf{Definition}  \\ 
\hline
DESC & Description  \\ 
\hline
DFS & Depth First Search Algorithm\\
\hline
Grid & This is where all the values are stored for the player to see.  \\ 
\hline
ID & Identification  \\ 
\hline
PW & Priority Weights  \\ 
\hline
User & Whoever will be using the app  \\ 
\hline
\end{tabular}

 

\section{Goals}
There are a few major goals that needed to be accomplished in this project. The main overaching goal was to create an intuitive Sudoku game UI and combine it with a Sudoku game solving component. This goal was thus broken into smaller pieces: create a user friendly UI for a user to be able to play a Sudoku game and create a efficient and fast Sudoku solver to solve any given puzzle. This program also needed to have a few additional components as well. The program must include some sort of searching algorithm and because of the complexity of the problem, it also needs to include some sort of pruning technique to minimize the operations needed to solve the entire game. The program also have some sort of database component to store all the puzzles in along with the current puzzle the user is working on. Another major goal was to turn this program into a mobile app that will run on Android devices and eventually on other systems as well. These were the main goals of the project that helped drive the focus of the project and its workers.

 
\section{Specific Requirements}
This section will cover the specific requirements of the project including functional and non-functional requirements. The functional requirements are identified with R followed by a number and nonfunctional requirements are identified with RQ followed by a number. All the functional requirements are marked with a PW (Priority Weight) which refer to the priority of that specific requirement with 5 being the highest priority and 1 being the lowest.

 
\subsection{Functional Requirements}
This section will cover the functional requirements associated with the project along with the following tags: ID, TITLE, DESC, and PW. \newline \newline
\textbf{ID:R1} \newline TITLE: Play Game Option\newline DESC: The user first opens up the app, they should be able to choose the option to play a Sudoku puzzle. They user should be able to stay as long as they want to on this screen.\newline PW: 3 \newline \newline
\textbf{ID:R2} \newline TITLE: Select Difficulty \newline DESC: The user should be able to select a difficulty setting that better suites needs at any time. There should be 5 difficulty options for the user to choose from. 1 being the easiest all the way down to 5 being the hardest.\newline PW: 2 \newline \newline
\textbf{ID:R3} \newline TITLE: Back Option \newline DESC: The user should be able to return to the main screen from the select difficulty screen if they don't select a difficulty. The user can remain on the select difficulty as long as the want to.\newline PW: 1 \newline \newline
\textbf{ID:R4} \newline TITLE: Continue Game \newline DESC: The user should be able to continue a game that has been previously started whether or not the app has been closed. All of the user's input should be saved so they could be brought up again should the user want to continue a game.\newline PW: 4 \newline \newline
\textbf{ID:R5} \newline TITLE: Get Puzzle \newline DESC: When the user selects a difficulty, a puzzle with the selected difficulty should be retrieved from the database for the user to be able to play it and enjoy the game.\newline PW: 2 \newline \newline
\textbf{ID:R6} \newline TITLE: Solver Option \newline DESC: On started, the user should be able to select the Solver option in the app to go straight to the solver part of the app. \newline PW: 5 \newline \newline
\textbf{ID:R7} \newline TITLE: Input Sudoku Puzzle To Solve \newline DESC: The user needs to be able to input any sort of Sudoku puzzle that the user has, with or without any extra numbers the user wishes to input. \newline PW: 5 \newline \newline
\textbf{ID:R8} \newline TITLE: Check Current Board \newline DESC: The user should be able to check the status of the current puzzle they are working on. The user should be able to view the inputs that are conflicting with each other. They should be marked in some way for the user to be able to see them clearly. \newline PW: 4 \newline \newline
\textbf{ID:R9} \newline TITLE: Delete an Input Value \newline DESC: The user should be able to delete an input value that they put in previously or a value that the system put in automatically. \newline PW: 5 \newline \newline
\textbf{ID:R10} \newline TITLE: Clear Board \newline DESC: The user should be able to clear the entire board easily and effortlessly. \newline PW: 3 \newline \newline
\textbf{ID:R11} \newline TITLE: Solve Current Board \newline DESC: The user should be able to have the option to solve the current board that they are working on. It should use the input the system put in as well as the inputs the user decided to add. \newline PW: 5 \newline \newline
\textbf{ID:R12} \newline TITLE: Play Sudoku Game \newline DESC: The user should be able to play a Sudoku game by selecting certain boxes and input a value into them. \newline PW: 4 \newline \newline
\textbf{ID:R13} \newline TITLE: Hint Option \newline DESC: The user should have the option to get a hint on the current Sudoku game they are playing. The hint should display any correct value on the given board. \newline PW: 1 \newline \newline
\textbf{ID:R14} \newline TITLE: Download Mobile Application \newline DESC: The user should be able to download the mobile application either from the Play Store or via Email to their Android phone. The download should be free. \newline PW: 5 \newline 

\subsection{Non-Functional Requirements} 
This section will cover the non-functional requirements associated with the project along with the following tags: ID, TITLE, and DESC. \newline \newline
\textbf{ID:RQ1} \newline TITLE: System Availability \newline DESC: The system needs to  be available to the user 99.9\% of the time, whether or not the system is being used. The system can only be down for 0.1\% of the time for updates or maintenance. \newline \newline
\textbf{ID:RQ2} \newline TITLE: Solve Time \newline DESC: The app should be able to solve a given Sudoku puzzle, whether there is or isn't a solution in under 5 seconds.\newline \newline
\textbf{ID:RQ3} \newline TITLE: Search Algorithm \newline DESC: The Suduko solver must utilize some search algorithm such as depth first search or breadth first search or any other searching algorithm. \newline \newline
\textbf{ID:RQ4} \newline TITLE: Pruning Technique \newline DESC: There must be some sort of pruning technique with solving the problem because 9\textsuperscript{81} is not feasible. \newline \newline
\textbf{ID:RQ5} \newline TITLE: Database Storage \newline DESC: The Database needs be stored locally on the device and new puzzles should be added to the device through updates or pulled from an external database. \newline \newline
\textbf{ID:RQ6} \newline TITLE: Easy to Use \newline DESC: The app should be very simple to use to any player with some general idea of how Sudoku puzzles work. \newline \newline
\textbf{ID:RQ7} \newline TITLE: Private Information \newline DESC: The app should not keep any personal information about the user. There app should not ask the user for any passwords. \newline \newline

\subsection{Version}
This is version 1.1 or v1.1, which is also the most current version of the system. Version 1.0 came out on the April 7, 2017; however, after tests were conducted there were a few design flaws that needed to be worked around. Version 1.0 was not able to solve difficult Sudoku puzzles within the allotted and many of the beta testers were not pleased with this. After some thought, v1.0 was pulled off the market and developers continued to improve the algorithm to solve the more difficult problems. In v1.1, the developers finally came up with a fast enough algorithm to solve it within the time limit. This new and updated version will be available on the market soon; however, it still remains in its early stages of development. 

\subsection{System Model}
This section will cover the general system model. This section includes the actors, use cases, use case diagram, prototyping and the traceability matrix.
\subsubsection{Actors}
The section covers the primary actors that are involved with the system directly or indirectly. \newline
\begin{itemize}
   \item Player: This is the primary actor who will be using the app as well as interacting with it.
   \item Database: This is the datastore that is on the device that contains all the Sudoku puzzles for the user to play.
\end{itemize}

\subsubsection{Use Cases}
This section covers the use cases that are most prominant in the Sudoku app that describe how the user shall interact with the app. Each use case will contain the following components: ID, Title, Actors, and Description.\newline \newline
\textbf{ID:UC1} \newline TITLE: Select Play Game \newline ACTORS: Player \newline DESC: Player opens up the app and selects to play a Sudoku puzzle. \newline \newline
\textbf{ID:UC2} \newline TITLE: Select Solver \newline ACTORS: Player \newline DESC: Player opens up the app and selects the Solver option to solve a Sudoku puzzle they might have. \newline \newline
\textbf{ID:UC3} \newline TITLE: Selecting a difficulty \newline ACTORS: Player and Database\newline DESC: Player selects a difficulty from the options available and a Sudoku board is filled with a puzzle similar to the difficulty the Player selected. \newline \newline
\textbf{ID:UC4} \newline TITLE: Quitting Time \newline ACTORS: Player and Database \newline DESC: When Player decides to quit the puzzle they are currently working on, the puzzle is saved to the database so Player can continue playing it.  \newline \newline
\textbf{ID:UC5} \newline TITLE: Continuing \newline ACTORS: Player and Database \newline DESC: When Player decides to play a game again and selects the continue option to bring up the previously saved game they were playing. \newline \newline
\textbf{ID:UC6} \newline TITLE: Give me a hint \newline ACTORS: Player \newline DESC: The Player is unsure of any other moves, so Player decides to select the hint option in order to recieve a hint about the current Sudoku puzzle they are working on. \newline \newline
\textbf{ID:UC7} \newline TITLE: Solve the Puzzle \newline ACTORS: Player \newline DESC: The Player is tired of playing and wants to see the solution to the Sudoku puzzle, so they decided to tap the solve button to get all the answers. \newline \newline
\textbf{ID:UC8} \newline TITLE: Clear the Board \newline ACTORS: Player \newline DESC: The Player decides to start a new puzzle, so the Player hits the clear button to erase everything on the board. \newline \newline
\textbf{ID:UC9} \newline TITLE: Playing the game \newline ACTORS: Player \newline DESC: The Player enjoys playing a Sudoku game by clicking the buttons and entering the numbers that they might think will solve the puzzle. \newline
\subsubsection{Use Case Diagram}
Figure \ref{fig:usecasediagram} depicts the the use case diagram used by the app as well as the develops to design a proper system.
\begin{figure*}[ht]\centering
	\includegraphics[width=4.0in]{./Figure/Usecase_Diagram.PNG}
	\caption{Use case diagram of the TESS System.}\label{fig:usecasediagram}
\end{figure*}

\subsubsection{Traceability Matrix}
The traceability matrix, as shown in Figure \ref{fig:traceabilitymatrix}, shows the priority weight of each use case based on the requirements that it meets. As per the figure, use case 9 had one of the highest priorities, which is consequently one of the most important use cases as well.
\begin{figure*}[ht]\centering
\includegraphics[width=4.0in]{./Figure/Traceability_Matrix.PNG}
\caption{Traceability Matrix of the TESS System.}\label{fig:traceabilitymatrix}
\end{figure*}

\section{System Design}
This is the system design section.

\subsection{Desgin Overview}
Provide an overview of the design, including diagrams, key design subsections, and how they relate or connect to one another (e.g., Interaction, structural models).

\subsection{Realistic Constraints and Professional Standards}
Identify and discuss realistic constraints on the problem, such that constraints may include economic, environmental, social, ethical, health and safety, manufacturability, policy issues, etc.
\begin{figure*}[ht]\centering
	\includegraphics[width=2.0in]{./Figure/User_Constraint.JPG}
	\caption{User constraints of the TESS System.}\label{fig:userconstraints}
\end{figure*}

\subsubsection{System Constraints}

The application design for Android smartphones requires to be implemented in Java. In addition to the programming language requirements, Android application development requires Android Studio IDE to be installed on the development computer. The IDE enables the developer to program and test the app on the same computer.\newline \newline
The IDE itself requires the developer to have a basic understanding of Android application development. It also requires the developer to configure an Android Virtual Device to run and test the app that is currently being developed.\newline
\newline
*We have outlined the six system constraints of TESS below. 
\newline
\textbf{ID:C1} \newline TITLE: Memory Space \newline DESC: The app should have a small footprint. The entire app should take up less than 5MBs of memory, this is including with future updates as well.\newline\newline
\textbf{ID:C2} \newline TITLE: Internet Connection for Updates\newline DESC: The app must have an internet connection established to be able to retrieve updated information from a master database. \newline\newline
\textbf{ID:C3} \newline TITLE: Programming Language \newline DESC: The app must be written in mainly Java, there may be other languages within the program, but the main part of it should be in Java.\newline\newline
\textbf{ID:C4} \newline TITLE: Android Device Only \newline DESC: The system must work on Android Devices, specifically the Galaxy Note 5 first, the following versions will include other phone models.\newline\newline
\textbf{ID:C5} \newline TITLE: Time to Solve \newline DESC: The app should take less than 5 seconds to output the solved Sudoku puzzle or report that it can't be solved.\newline\newline
\textbf{ID:C6} \newline TITLE: Database Usage \newline DESC: The app must utilize some sort of database to hold the stored puzzles.\newline\newline



\subsection{Alternative Designs and Design Choices}
Describe alternative designs that were considered during execution of the project. Discuss how design choices were guided by constraints and other factors. E.g., architectural design models – Layered or Client-server and details shown using activity diagram as shown in Figure \ref{fig:activitydiagram} (Context model), sequence diagram (Interaction model), class diagram (Structural model).

\begin{figure*}[h!]
	\centering
	\includegraphics[width=5.0in]{./Figure/Activity_Diagram.PNG}
	\caption{Activity diagram of the TESS system.}\label{fig:activitydiagram}
\end{figure*}

stuff \newline
stuff \newline
stuff \newline

stuff \newline
\begin{figure*}[h!]
	\centering
	\includegraphics[width=5.0in]{./Figure/Sequence_Diagram.PNG}
	\caption{Sequence diagram of the TESS system.\cite{UMLDoc}}
	\label{fig:sequencediagram}
\end{figure*}

\section{System Implementation}
This is the system inplementation section.

Describe the technical details for each of the subsystems or a the system-level and
provide sequence diagrams or station/activity diagrams for your system implementation.

\iffalse
\ref{fig:UI1}
\begin{figure}[h!]
	\begin{subfigure}{\linewidth}
		\includegraphics[width=.3\linewidth]{./Figure/Check.PNG}\hfill
		\includegraphics[width=.3\linewidth]{./Figure/Solve.PNG}
		\caption{1}
		\label{fig:UI1}
	\end{subfigure}\par\medskip
	\begin{subfigure}{\linewidth}
		\includegraphics[width=.3\linewidth]{./Figure/Check.PNG}\hfill
		\includegraphics[width=.3\linewidth]{./Figure/Solve.PNG}
		\caption{2}
		\label{fig:UI2}
	\end{subfigure}\par\medskip
	\begin{subfigure}{\linewidth}
		\includegraphics[width=.3\linewidth]{./Figure/Check.PNG}\hfill
		\includegraphics[width=.3\linewidth]{./Figure/Solve.PNG}
		\caption{3}
		\label{fig:UI3}
	\end{subfigure}
	\caption{User interface of the TESS system.}
\end{figure}
\fi



\section{System Testing}
This section will describe the testing plan for TESS and the different tests that will be conducted on it. This section will also display the results of the tests.

\subsection{Test Plan}
This section will describe the tesing plan for the system. Due to the nature of the project, the testing phase is only applicable to a small portion of the project. Since there is no input directly from the user and there are only buttons available for the user to use, the testing will be rather minimal. The project was created in such a way as to reduce the chance of errors, so the developers chose to use only buttons in the UI. There are a few major methods that do require testing, they are: solveHorizonal(), solveVertical(), solveBox(), and solveRecur(). For the first three methods there will be 2 tests each, one showing where it solves the expected square and the other where there is no way for it solve it. These cases are simple and are only used to solve the easy cases in the app in order to cut down the time of having the DFS run through the different possibilities. For the final method, solveRecur(), there will be 5 tests run, one from each difficulty to show that those puzzles can be solved and also 1 test case where the input is invalid. All of the aforementioned tests are unit tests, specifically Black-box tests. This specific type of test involves giving the program a set of input and testing it with the expected output. The other kind of unit tests are called White-box tests, in which there are multiple tests within a single unit test. For this project there is only one applicable place where White-box testing is necessary. In the solve function, solve(), that solves the entire puzzle, it relies on all four of the aforementioned methods as well as a secondary function that the solveRecur() calls on recursively, solveRecurCheck(). There will be 1 White-box test where each method is directly dependent on the other in order to produce the correct solution and also 1 other White-box test to perform the same test on invalid input. Due to the nature of the project, the integration testing is directly associated with the unit testing. The two different testing phases are intertwined within each other, so the aforementioned tests are also the integration tests as well. The integration tests are based on the bottom-up approach. There will be one specific system test that will be written because the only test that will need to be performed on the app is the performance test and this will tested by using one the most difficult Sudoku puzzles known to man. The test will check whether the app can solve it within the 5 second limit. There aren't any other system tests to create due to the nature of the app. These are all the tests that will need to be created and run to make sure the app works properly. Since this is still in the beta stages, there will be user testing and the app will be provided to select individuals to run the app and report back with their findings.

\subsection{Test Results}
This section will describe the test results in detail. The test results went as expected. As seen in Figure \ref{fig:tests}, all the tests passed. In Figure \ref{fig:horizontalTest} is an example of the many unit and integration tests that were written. The two different types of tests are interweaved so there aren't specific tests for one type. Most of these tests were written with the Black-box test design; however, the solve function was written with White-box test design in mind. These tests were created to make sure individual methods were working properly. Since the system is minimalistic and avoids any security risks there was only one main system test to design, this was the performance tests. As depicted in Figure \ref{fig:performanceTest}, the system test uses a time limit approach were it records the start time and the finish time. Then it converts the difference into seconds and returns whether the program solves it under the time constraint. This is one of the more important tests due the system constraints mentioned earlier. As shown per Figure \ref{fig:tests}, the performance test is under the time allotted for the program to solve any puzzle. The user tests are still in progress and there have not been any know issues yet. Overall, the tests were a success.
\begin{figure*}[ht]\centering
\includegraphics[width=4.0in]{./Figure/unit_test_results.PNG}
\caption{Results of test cases}\label{fig:tests}
\end{figure*}
\begin{figure*}[ht]\centering
\includegraphics[width=4.0in]{./Figure/solve_horizontal_test.PNG}
\caption{Test: solveHorizontalTest()}\label{fig:horizontalTest}
\end{figure*}
\begin{figure*}[ht]\centering
\includegraphics[width=4.0in]{./Figure/performance_test.PNG}
\caption{Test: performanceTest()}\label{fig:performanceTest}
\end{figure*}

\section{Conclusions}
This is the conclusions section.

Overall summary of design methodologies, key creative approaches and potential
contribution/impact. \cite{hahahaha}

\bibliographystyle{IEEEtran}
\bibliography{Bibliography}


 
\end{document}